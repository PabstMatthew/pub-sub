#lang ivy1.8

include numbers
include network
include order
include collections

# Types.
global {
    # Key type used to identify pub/sub channels.
    instance key_t : iterable

    # Value type used in channels.
    alias byte = uint[8]
    alias val_t = byte
    instance log_t : vector(val_t)

    # IDs for different processes.
    instance client_id : iterable
    instance server_id : iterable
    instance manager_id : iterable
}

process client (self:client_id) = {

    # Subscribe to a particular key.
    export action subscribe_req(key:key_t)
    # In response,receive `content`, a log of all previous messages for this key.
    # Once this message is received,the client will also receive `publish_rsp`
    # when values are published to this key.
    import action subscribe_rsp(key:key_t,content:log_t)
    # TODO add unsubscribe action

    # Publish a value to this key. Expected to only be called after a corresponding 
    # `subscribe_req` and `subscribe_rsp`.
    export action publish_req(key:key_t,val:val_t)
    # Callback to notify clients when a value has been published to a key they've 
    # subscribed to. This includes values published by themself.
    import action publish_rsp(key:key_t,val:val_t,src:client_id)

    specification {
    }

    common {

        specification {

            var pending_subscribe(X:client_id,K:key_t) : bool   # a subscribe is pending for this key
            var subscribed(X:client_id,K:key_t) : bool          # this client is subscribed to this key
            # all the pending values published by this client to this key
            instance pending_pubs(X:client_id,K:key_t) : unbounded_queue(val_t)  

            after init {
                pending_subscribe(X,K) := false;
                subscribed(X,K) := false;
                # TODO: initialize any state
            }

            before subscribe_req(self:client_id,key:key_t,val:val_t) {
                require ~pending_subscribe(self,key) & ~subscribed(self,key);
                pending_subscribe(self,key) := true;
            }

            before subscribe_rsp(self:client_id,key:key_t,content:log_t) {
                require pending_subscribe(self,key);
                pending_subscribe(self,key) := false;
                subscribed(self,key) := true;
                # TODO do something with content received
            }

            before publish_req(self:client_id,key:key_t,val:val_t) {
                require subscribed(self,key);
                pending_pubs(self,key).enqueue(val);
                # TODO do something with published value
            }

            before publish_rsp(self:client_id,key:key_t,val:val_t,src:client_id) {
                require subscribed(self,key);
                # Check that clients see sequential consistency for their own publications.
                if src = self {
                    require ~pending_pubs(self,key).empty &
                             pending_pubs(self,key).dequeue = val;
                }
                # TODO check that the history is linearizable (or something similar)
            }
        }
    }
}

